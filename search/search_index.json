{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTING/","title":"How to contribute","text":""},{"location":"CONTRIBUTING/#making-changes","title":"Making changes","text":"<p>Before making changes create a personal fork of the repository. Sync fork and create new branch from the latest version of the <code>main</code> branch. Create separate branch for each change. Thus it is simpler to support consistent state of the <code>main</code> in your fork.</p> <p>Prefer incremental commits to one big commit which contains the whole change. Prefer commits which passes all of the tests. If it is not possible to satisfy both requirements at once you can make single commit which passes tests or mark tests as ignored until change is done.</p> <p>Each commit should have a message in the following format: <pre><code>Change summary in 50 characters (less than 73 characters)\n\nOptional detailed description of the change when required. Each line\nis less than 73 character long.\n</code></pre> Such commits looks better in GitHub history.</p> <p>Please avoid generic commit messages like <code>Update README.md</code>. Good commit message should describe the change, not a fact of the change. For example <code>Add troubleshooting section about No module named 'hyperonpy'</code>. By looking to the commit message history the reviewer should understand the order and brief description of changes.</p> <p>Please don't include number and description of the issue into a commit summary line. Use <code>Fixes #&lt;issue-number&gt;</code> in the pull request description instead to link the PR and the issue.</p> <p>PR should satisfy the following requirement before being merged: - contain latest changes from the repo; - pass tests; - be reviewed.</p> <p>Feel free to raise draft PR if you need an advice or help with your changes.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code style","text":"<p>We have small set of code style rules for now. The rule of thumb is to take a look at the existing code and stick to its style.</p>"},{"location":"CONTRIBUTING/#general","title":"General","text":"<p>If you want to leave some reminder in code, for example to fix something later, you can do it by two ways. Add a comment starting with <code>FIXME</code> to mark something which should be done before the PR is merged. Add a comment starting with <code>TODO</code> to mark the improvement which can be postponed and done later by a separate PR. The main purpose of a <code>TODO</code> comment is to trigger a developer who looks at the code after you and make him fix the issue if it is appropriate. If the change or question is big enough or it affects the API of the module it is better to raise an issue instead.</p>"},{"location":"CONTRIBUTING/#libraries","title":"Libraries","text":"<p>When adding new library into the project please ensure you specify the exact version instead of using ranges. The minor update of the library can break the build unexpectedly. The broken build is a real burden because most of the users build the project from the source.</p>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<p>When working on Rust C API prefer making <code>unsafe</code> blocks as small as possible. This makes it easier to find blocks that might be source of issues. Usually it is not required to mark C API functions <code>unsafe</code> because they are not intended to be used from the Rust safe code.</p>"},{"location":"minimal-metta/","title":"Minimal Metta","text":"<p>This document describes the minimal set of embedded MeTTa instructions which is designed to write the complete MeTTa interpreter in MeTTa. Current version of the document includes improvements which were added after experimenting with the first version of such an interpreter. It is not a final version and some directions of the future work is explained at the end of the document.</p>"},{"location":"minimal-metta/#minimal-instruction-set","title":"Minimal instruction set","text":""},{"location":"minimal-metta/#interpreter-state","title":"Interpreter state","text":"<p>The MeTTa interpreter evaluates an atom passed as an input. It evaluates it step by step executing a single instruction on each step. In order to do that the interpreter needs a context which is wider than the atom itself. The context also includes: - an atomspace which contains the knowledge which drives the evaluation of the   expressions; - bindings of the variables which are used to evaluate expressions; the   bindings are empty at the beginning (see Explicit atomspace variable   bindings).</p> <p>Each step of interpretation inputs and outputs a list of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>) which is called interpretation plan. Each pair in the plan represents one possible way of interpreting the original atom or possible branch of the evaluation. Interpreter doesn't select one of them for further processing. It continues interpreting all of the branches in parallel. Below this is called non-deterministic evaluation.</p> <p>One step of the interpretation is an execution of a single instruction from a plan. An interpreter extracts atom and bindings from the plan and evaluates the atom. The result of the operation is a set of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>). Bindings of the result are merged with the previous bindings. Merge operation can also bring more than one result. Each such result is added as a separate pair into a result set. Finally all results from result set are added into the plan and step finishes.</p> <p>Here we suppose that on the top level the plan contains only the instructions from the minimal set. If an instruction returns the atom which is not from the minimal set it is not interpreted further and returned as a part of the final result. Thus only the instructions of the minimal set are considered a code other atoms are considered a data.</p>"},{"location":"minimal-metta/#evaluation-order","title":"Evaluation order","text":"<p>MeTTa implements the applicative evaluation order by default, arguments are evaluated before they are passed to the function. User can change this order using special meta-types as the types of the arguments. Minimal MeTTa operations don't rely on types and minimal MeTTa uses the fixed normal evaluation order, arguments are passed to the function without evaluation. But there is a chain operation which can be used to evaluate an argument before passing it. Thus <code>chain</code> can be used to change evaluation order in MeTTa interpreter.</p>"},{"location":"minimal-metta/#erroremptynotreducible","title":"Error/Empty/NotReducible/()","text":"<p>There are atoms which can be returned to designate a special situation in a code: - <code>(Error &lt;atom&gt; &lt;message&gt;)</code> means the interpretation is finished with error; - <code>Empty</code> means the corresponding branch of the evaluation returned no results,   such result is not returned among other results when interpreting is   finished; - <code>NotReducible</code> can be returned by <code>eval</code> in order to designate that function   can not be reduced further; for example it can happen when code tries to call   a type constructor (which has no definition), partially defined function   (with argument values which are not handled), or grounded function which   returns <code>NotReducible</code> explicitly; this atom is introduced to separate the   situations when atom should be returned \"as is\" from <code>Empty</code> when atom should   be removed from results; - Empty expression <code>()</code> is an instance of the unit type which is mainly used by   functions with side effects which has no meaningful value to return.</p> <p>These atoms are not interpreted further as they are not a part of the minimal set of instructions and considered a data.</p>"},{"location":"minimal-metta/#eval","title":"eval","text":"<p><code>(eval &lt;atom&gt;)</code> is a first instruction which evaluates an atom passed as an argument. Evaluation is different for the grounded function calls (the expression with a grounded atom on a first position) and pure MeTTa expressions. For the pure MeTTa expression the interpreter searches the <code>(= &lt;atom&gt; &lt;var&gt;)</code> expression in the atomspace. The found values of the <code>&lt;var&gt;</code> are the result of evaluation. Execution of the grounded atom leads to the call of the foreign function passing the tail of the expression as arguments. For example <code>(+ 1 2)</code> calls the implementation of addition with <code>1</code> and <code>2</code> as arguments.  The list of atoms returned by the grounded function is a result of the evaluation in this case. A grounded function can have side effects as well. In both cases bindings of the <code>eval</code>'s argument are merged to the bindings of the result.</p> <p>Atomspace search can bring the list of results which is empty. When search returns no results then <code>NotReducible</code> atom is a result of the instruction. Grounded function can return a list of atoms, empty result, <code>ExecError::Runtime(&lt;message&gt;)</code> or <code>ExecError::NoReduce</code> result. The result of the instruction for a special values are the following: - <code>ExecError::Runtime(&lt;message&gt;)</code> returns <code>(Error &lt;original-atom&gt; &lt;message&gt;)</code>   atom; - <code>ExecError::NoReduce</code> returns <code>NotReducible</code> atom; - currently empty result removes result from the result set. It is done mainly   for compatibility. There is no valid reason to return an empty result from a   grounded function. Function can return <code>()/Empty/NotReducible</code> to express \"no   result\"/\"remove my result\"/\"not defined on data\".</p>"},{"location":"minimal-metta/#chain","title":"chain","text":"<p>Minimal MeTTa implements normal evaluation order (see Evaluation order. Arguments are passed to the function without evaluation. In case when argument should be evaluated before calling a function one can use <code>chain</code> instruction.</p> <p><code>chain</code>'s signature is <code>(chain &lt;atom&gt; &lt;var&gt; &lt;template&gt;)</code> and it is executed in two steps. <code>&lt;atom&gt;</code> argument is evaluated first and bindings of the evaluation result are merged to the bindings of the current result. After that <code>chain</code> substitutes all occurrences of <code>&lt;var&gt;</code> in <code>&lt;template&gt;</code> by the result of the evaluation and returns result of the substitution. When evaluation of the <code>&lt;atom&gt;</code> brings more than a single result <code>chain</code> returns one instance of the <code>&lt;template&gt;</code> expression for each result.</p>"},{"location":"minimal-metta/#functionreturn","title":"function/return","text":"<p><code>function</code> operation has the signature <code>(function &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> until it becomes <code>(return &lt;atom&gt;)</code>. Then <code>(function (return &lt;atom&gt;))</code> expression returns the <code>&lt;atom&gt;</code>.</p> <p>These operations are introduced for two reasons. First it should be possible to evaluate an atom until some result and prevent further result evaluation. This aspect is discussed in eval or return section.</p> <p>Second without having an abstraction of a function call it is difficult to debug the evaluation process. <code>function/return</code> allows representing nested function calls as a stack and provide controls to put the breakpoints on parts of this stack. Nevertheless using <code>chain</code> instead of <code>function</code> to implement the evaluation loop also allows representing stack in a natural form.</p>"},{"location":"minimal-metta/#unify","title":"unify","text":"<p><code>unify</code> operation allows conditioning on the results of the evaluation. <code>unify</code>'s signature is <code>(unify &lt;atom&gt; &lt;pattern&gt; &lt;then&gt; &lt;else&gt;)</code>. The operation matches <code>&lt;atom&gt;</code> with a <code>&lt;pattern&gt;</code>. If match is successful then it returns <code>&lt;then&gt;</code> atom and merges bindings of the original <code>&lt;atom&gt;</code> to resulting variable bindings. If matching is not successful then it returns the <code>&lt;else&gt;</code> branch with the original variable bindings.</p>"},{"location":"minimal-metta/#cons-atomdecons-atom","title":"cons-atom/decons-atom","text":"<p><code>cons-atom</code> and <code>decons-atom</code> allows constructing and deconstructing the expression atom from/to pair of the head and tail. <code>(decons-atom &lt;expr&gt;)</code> expects non-empty expression as an argument and returns a pair <code>(&lt;head&gt; &lt;tail&gt;)</code>. <code>(cons-atom &lt;head&gt; &lt;tail&gt;)</code> returns an expression where the first sub-atom is <code>&lt;head&gt;</code> and others are copied from <code>&lt;tail&gt;</code>.</p>"},{"location":"minimal-metta/#collapse-bind","title":"collapse-bind","text":"<p><code>collapse-bind</code> has the signature <code>(collapse-bind &lt;atom&gt;)</code>. It evaluates the <code>&lt;atom&gt;</code> and returns an expression which contains all alternative evaluations in a form <code>(&lt;atom&gt; &lt;bindings&gt;)</code>. <code>&lt;bindings&gt;</code> are represented in a form of a grounded atom.</p> <p><code>collapse-bind</code> is part of the inference control provided by a minimal MeTTa interpreter. For example it can be used to get all alternative interpretations of the atom and filter out ones which led to errors.</p> <p>Name <code>collapse-bind</code> is temporary and chosen to eliminate conflict with <code>collapse</code> which is part of the standard library.</p>"},{"location":"minimal-metta/#superpose-bind","title":"superpose-bind","text":"<p><code>superpose-bind</code> has the signature <code>(superpose-bind ((&lt;atom&gt; &lt;bindings&gt;) ...))</code>. It puts list of the results into the interpreter plan each pair as a separate alternative.</p> <p><code>superpose-bind</code> is an operation which is complement to the <code>collapse-bind</code>. <code>superpose-bind</code> takes the result of the <code>collapse-bind</code> as an input. Thus user can collect the list of alternatives using <code>collapse-bind</code> filter them and return filtered items to the plan using <code>superpose-bind</code>.</p>"},{"location":"minimal-metta/#examples","title":"Examples","text":"<p>Examples of the programs written using minimal MeTTa interpreter:</p> <p>Recursive switch implementation:</p> <pre><code>(= (switch $atom $cases)\n  (function\n    (chain (decons-atom $cases) $list\n      (chain (eval (switch-internal $atom $list)) $res\n        (unify $res NotReducible (return Empty) (return $res)) ))))\n\n(= (switch-internal $atom (($pattern $template) $tail))\n  (function\n    (unify $atom $pattern\n      (return $template)\n      (chain (eval (switch $atom $tail)) $ret (return $ret)) )))\n</code></pre> <p>Evaluate atom in a loop until result is calculated:</p> <pre><code>(= (subst $atom $var $templ)\n  (unify $atom $var $templ\n    (Error (subst $atom $var $templ)\n      \\\"subst expects a variable as a second argument\\\") ))\n\n(= (reduce $atom $var $templ)\n  (chain (eval $atom) $res\n    (unify $res Empty\n    Empty\n    (unify $res (Error $a $m)\n      (Error $a $m)\n      (unify $res NotReducible\n        (eval (subst $atom $var $templ))\n        (eval (reduce $res $var $templ)) )))))\n</code></pre> <p>Link to the full code of the interpreter in MeTTa.</p>"},{"location":"minimal-metta/#properties","title":"Properties","text":""},{"location":"minimal-metta/#turing-completeness","title":"Turing completeness","text":"<p>The following program implements a Turing machine using the minimal MeTTa instruction set (the full code of the example can be found here):</p> <pre><code>(= (tm $rule $state $tape)\n  (function (eval (tm-body $rule $state $tape))) )\n\n(= (tm-body $rule $state $tape)\n  (unify $state HALT\n    (return $tape)\n    (chain (eval (read $tape)) $char\n      (chain (eval ($rule $state $char)) $res\n        (unify $res ($next-state $next-char $dir)\n          (chain (eval (move $tape $next-char $dir)) $next-tape\n            (eval (tm-body $rule $next-state $next-tape)) )\n          (return (Error (tm-body $rule $state $tape) \\\"Incorrect state\\\")) )))))\n\n(= (read ($head $hole $tail)) $hole)\n\n(= (move ($head $hole $tail) $char N) ($head $char $tail))\n(= (move ($head $hole $tail) $char L) (function\n  (chain (cons-atom $char $head) $next-head\n    (chain (decons-atom $tail) $list\n      (unify $list ($next-hole $next-tail)\n        (return ($next-head $next-hole $next-tail))\n        (return ($next-head 0 ())) )))))\n(= (move ($head $hole $tail) $char R) (function\n  (chain (cons-atom $char $tail) $next-tail\n    (chain (decons-atom $head) $list\n      (unify $list ($next-hole $next-head)\n        (return ($next-head $next-hole $next-tail))\n        (return (() 0 $next-tail)) )))))\n</code></pre>"},{"location":"minimal-metta/#comparison-with-metta-operational-semantics","title":"Comparison with MeTTa Operational Semantics","text":"<p>One difference from MOPS [1] is that the minimal instruction set allows relatively easy write deterministic programs and non-determinism is injected only via matching and evaluation. <code>Query</code> and <code>Chain</code> from MOPS are very similar to <code>eval</code>. <code>Transform</code> is very similar to <code>unify</code>. <code>chain</code> has no analogue in MOPS. <code>cons-atom</code>/<code>decons-atom</code> to some extent are analogues of <code>AtomAdd</code>/<code>AtomRemove</code> in a sense that they can be used to change the state.</p>"},{"location":"minimal-metta/#partial-and-complete-functions","title":"Partial and complete functions","text":"<p>Each instruction in a minimal instruction set is a total function. Nevertheless <code>Empty</code> allows defining partial functions in MeTTa. For example partial <code>if</code> can be defined as follows: <pre><code>(= (if $condition $then) (unify $condition True $then Empty))\n</code></pre></p>"},{"location":"minimal-metta/#eval-or-return","title":"eval or return","text":"<p>Using <code>eval</code> to designate evaluation of the atom seems too verbose. But we need to give a programmer some way to designate whether the atom should be evaluated or not. <code>eval</code> marks atoms which should be evaluated. As an alternative to this solution we could mark atoms which should not be evaluated.</p> <p>Another related issue is that we need ability to make complex evaluations before making a substitution inside <code>chain</code>. For example <code>(chain (eval (foo a)) $x $x)</code> should be able to make and fully evaluate the call of the <code>foo</code> function before inserting the result into the template. We need to define the criteria which specifies when the nested operation is finished and what is the result. Also we need to be able represent evaluation loop inside the code.</p> <p>First version of the minimal interpreter continued the evaluation of the first argument of the <code>chain</code> until it becomes a non-minimal MeTTa instruction. But this approach is too verbose. If it is needed to chain some minimal MeTTa instruction without evaluation then such instruction should be wrapped into a non-minimal MeTTa expression and unwrapped after the substitution is made.</p> <pre><code>  (chain (quote (eval (foo))) $x\n    (unify $x (quote $y)\n      $y\n      (Error $x \"quote expression expected\") ))\n</code></pre> <p>To allow <code>chain</code> relying on the returned result of the first argument the <code>function/return</code> operations are introduced. When user needs to run a complex evaluation inside chain he may wrap it into the <code>function</code> operation. <code>function</code> evaluates its argument in a loop until <code>(return &lt;atom&gt;)</code> is returned. Then it returns the <code>&lt;atom&gt;</code> as a result. If one need to make a substitution it is possible using:</p> <pre><code>  (chain (function (return &lt;atom&gt;)) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>One more option is to make <code>chain</code> (and other atoms which can have nested evaluation loops) recognize <code>return</code>. In such case the evaluation loop is executed by the <code>chain</code> itself and <code>function</code> instruction is not needed. Substitution gets the simpler form:</p> <pre><code>  (chain (return &lt;atom&gt;) &lt;var&gt; &lt;templ&gt;)\n</code></pre> <p>The downside of this approach is that loop represented by the outer operation <code>chain</code> and end of the loop represented by <code>return</code> are written in different contexts. Thus programmer should keep in mind that when some function is used from <code>chain</code> and it is not just a equality substitution then <code>return</code> should be used on each exit path while nothing in code of function points to this. Using <code>function</code> operation allows dividing functions on two classes: - functions which evaluate result in a loop and have to use <code>return</code>; - functions which just replace the calling expression by their bodies.</p>"},{"location":"minimal-metta/#future-work","title":"Future work","text":""},{"location":"minimal-metta/#explicit-atomspace-variable-bindings","title":"Explicit atomspace variable bindings","text":"<p>Current implementation implicitly keeps and applies variable bindings during the process of the interpretation. Explicit bindings are used to implement <code>collapse-bind</code> where they are absolutely necessary. Bindings can be easily made explicit everywhere but the value of explicit bindings is not obvious see [discussion in issue</p>"},{"location":"minimal-metta/#290httpsgithubcomtrueagi-iohyperon-experimentalissues290issuecomment-1541314289","title":"290](https://github.com/trueagi-io/hyperon-experimental/issues/290#issuecomment-1541314289).","text":"<p>Making atomspace part of the explicit context could make import semantics more straightforward. In the current implementation of the minimal instruction set it is needed to explicitly pass the atomspace to the interpreter because otherwise grounded <code>get-type</code> function didn't work properly. It also could allow defining <code>eval</code> via <code>unify</code> which minimizes the number of instructions and allows defining <code>eval</code> in a MeTTa program itself. Which in turn allows defining different versions of <code>eval</code> to program different kinds of chaining. Nevertheless defining <code>eval</code> through <code>unify</code> requires rework of the grounded functions interface to allow calling them by executing <code>unify</code> instructions. Which is an interesting direction to follow.</p>"},{"location":"minimal-metta/#scope-of-variables","title":"Scope of variables","text":"<p>Scope of the variable inside instructions is not described in this specification. It is a clear gap and one of the TODO items.</p>"},{"location":"minimal-metta/#special-matching-syntax","title":"Special matching syntax","text":"<p>Sometimes it is convenient to change the semantics of the matching within a pattern. Some real examples are provided below. One possible way to extend matching syntax is embrace atoms by expressions with matching modifier on a first position. For instance <code>(:&lt;mod&gt; &lt;atom&gt;)</code> could apply <code>&lt;mod&gt;</code> rule to match the <code>&lt;atom&gt;</code>. How to eliminate interference of this syntax with symbol atoms used by programmers is an open question.</p>"},{"location":"minimal-metta/#syntax-to-match-atom-by-equality","title":"Syntax to match atom by equality","text":"<p>In many situations we need to check that atom is equal to some symbol. <code>unify</code> doesn't work well in such cases because when checked atom is a variable it is matched with anything (for instance <code>(unify $x Empty then else)</code> returns <code>then</code>). It would be convenient to have a special syntax to match the atom by equality. For instance <code>(unify &lt;atom&gt; (:= Empty) then else)</code> should match <code>&lt;atom&gt;</code> with pattern only when <code>&lt;atom&gt;</code> is <code>Empty</code>.</p>"},{"location":"minimal-metta/#syntax-to-match-part-of-the-expression","title":"Syntax to match part of the expression","text":"<p>We could have a specific syntax which would allow matching part of the expressions. For example such syntax could be used to match head and tail of the expression without using <code>cons-atom</code>/<code>decons-atom</code>. Another example is matching part of the expression with some gap, i.e. <code>(A ... D ...)</code> could match <code>(A B C D E)</code> atom.</p>"},{"location":"minimal-metta/#links","title":"Links","text":"<ol> <li>Lucius Gregory Meredith, Ben Goertzel, Jonathan Warrell, and Adam    Vandervorst. Meta-MeTTa: an operational semantics for MeTTa.    https://raw.githubusercontent.com/leithaus/rho4u/main/ai/mops/mops.pdf</li> </ol>"},{"location":"reference/atoms/","title":"Atoms","text":""},{"location":"reference/atoms/#hyperon.atoms","title":"atoms","text":"<p>The Python wrapper for Hyperon Atom Rust types</p>"},{"location":"reference/atoms/#hyperon.atoms.Atom","title":"Atom","text":"<pre><code>Atom(catom)\n</code></pre> <p>Represents an Atom of any type</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an Atom\"\"\"\n    self.catom = catom\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n    \"\"\"Gets the type of the current Atom instance\"\"\"\n    return hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.AtomType","title":"AtomType","text":"<p>Defines all Atom types</p>"},{"location":"reference/atoms/#hyperon.atoms.Bindings","title":"Bindings","text":"<pre><code>Bindings(bindings: Union[CBindings, None] = None)\n</code></pre> <p>Interface for working with atom matching and variable-to-atom binding.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, bindings: Union[hp.CBindings, None] = None):\n    \"\"\"Initializes with or without pre-existing bindings.\"\"\"\n    if bindings is None:\n        self.cbindings = hp.bindings_new()\n    else:\n        self.cbindings = bindings\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of the bindings.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of the bindings.\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the binding resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the binding resources.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two bindings objects contain identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two bindings objects contain identical associations.\"\"\"\n    return (isinstance(other, Bindings) and\n            hp.bindings_eq(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.cbindings is not None:\n        hp.bindings_free(self.cbindings)\n        self.cbindings = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of the bindings\"\"\"\n    return hp.bindings_to_str(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: Union[str, Atom], atom: Atom) -&gt; bool\n</code></pre> <p>Adds a binding between a variable and an Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: Union[str, Atom], atom: Atom) -&gt; bool:\n    \"\"\"Adds a binding between a variable and an Atom.\"\"\"\n    if isinstance(var, Atom):\n        return hp.bindings_add_var_binding(self.cbindings, var.get_name(), atom.catom)\n    else:\n        return hp.bindings_add_var_binding(self.cbindings, var, atom.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of the bindings\"\"\"\n    return Bindings(hp.bindings_clone(self.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a bindings contains no associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a bindings contains no associations.\"\"\"\n    return hp.bindings_is_empty(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over the variable-atom pairs in the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over the variable-atom pairs in the bindings\"\"\"\n    res = hp.bindings_list(self.cbindings)\n    result = []\n    for r in res:\n        result.append((r[0], Atom._from_catom(r[1])))\n\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.merge","title":"merge","text":"<pre><code>merge(other: Bindings) -&gt; BindingsSet\n</code></pre> <p>Merges with another Bindings instance, into a Bindings Set.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge(self, other: 'Bindings') -&gt; 'BindingsSet':\n    \"\"\"Merges with another Bindings instance, into a Bindings Set.\"\"\"\n    return BindingsSet(hp.bindings_merge(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.narrow_vars","title":"narrow_vars","text":"<pre><code>narrow_vars(vars)\n</code></pre> <p>Keeps only specific variable associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def narrow_vars(self, vars ):\n    \"\"\"Keeps only specific variable associations.\"\"\"\n    cvars = hp.CVecAtom = hp.atom_vec_new()\n    for var in vars:\n        hp.atom_vec_push(cvars, var.catom)\n    hp.bindings_narrow_vars(self.cbindings, cvars)\n    hp.atom_vec_free(cvars)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.resolve","title":"resolve","text":"<pre><code>resolve(var_name: str) -&gt; Union[Atom, None]\n</code></pre> <p>Finds the atom for a given variable name</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def resolve(self, var_name: str) -&gt; Union[Atom, None]:\n    \"\"\"Finds the atom for a given variable name\"\"\"\n    raw_atom = hp.bindings_resolve(self.cbindings, var_name)\n    return None if raw_atom is None else Atom._from_catom(raw_atom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet","title":"BindingsSet","text":"<pre><code>BindingsSet(input: Union[CBindingsSet, Bindings, None] = None)\n</code></pre> <p>Represents a set of Bindings frames, potentially expressing all possible matches produced by a match operation.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, input: Union[hp.CBindingsSet, Bindings, None] = None):\n    \"\"\"Initializes with optional input.\"\"\"\n    self.shadow_list = None # A lazily initialized list that shadows the BindingsSet values for indexed access\n    if input is None:\n        self.c_set = hp.bindings_set_single()\n    elif isinstance(input, Bindings):\n        self.c_set = hp.bindings_set_from_bindings(input.cbindings)\n    else:\n        self.c_set = input\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict={})\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees the BindingsSet\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n    \"\"\"For context management.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if other BindingsSet contains identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if other BindingsSet contains identical associations.\"\"\"\n    return (isinstance(other, BindingsSet) and\n            hp.bindings_set_eq(self.c_set, other.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Frees resources on exit.\"\"\"\n    if self.c_set is not None:\n        hp.bindings_set_free(self.c_set)\n        self.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Gets a Bindings frame by index</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Gets a Bindings frame by index\"\"\"\n    if self.shadow_list is None:\n        result = hp.bindings_set_unpack(self.c_set)\n        self.shadow_list = [{k: Atom._from_catom(v) for k, v in bindings.items()} for bindings in result]\n    return self.shadow_list[key]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a text description of a BindingsSet\"\"\"\n    return hp.bindings_set_to_str(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: Union[str, Atom], value: Atom) -&gt; bool\n</code></pre> <p>Adds a new variable to atom association to every Bindings frame in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: Union[str, Atom], value: Atom) -&gt; bool:\n    \"\"\"Adds a new variable to atom association to every Bindings frame in a\n    BindingsSet.\n    \"\"\"\n    self.shadow_list = None\n    if isinstance(var, Atom):\n        return hp.bindings_set_add_var_binding(self.c_set, var.catom, value.catom)\n    else:\n        return hp.bindings_set_add_var_binding(self.c_set, V(var), value.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_equality","title":"add_var_equality","text":"<pre><code>add_var_equality(a: Atom, b: Atom) -&gt; bool\n</code></pre> <p>Asserts equality between two Variable atoms in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_equality(self, a: Atom, b: Atom) -&gt; bool:\n    \"\"\"Asserts equality between two Variable atoms in a BindingsSet.\"\"\"\n    self.shadow_list = None\n    return hp.bindings_set_add_var_equality(self.c_set, a.catom, b.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n    \"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\n    return BindingsSet(hp.bindings_set_clone(self.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.empty","title":"empty","text":"<pre><code>empty()\n</code></pre> <p>Creates a new BindingsSet without any Bindings frames. Conceptually, this means no valid matches exist.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def empty():\n    \"\"\"Creates a new BindingsSet without any Bindings frames.\n    Conceptually, this means no valid matches exist.\n    \"\"\"\n    return BindingsSet(hp.bindings_set_empty())\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a BindingsSet contains no Bindings frames, and thus indicates no match.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Checks if a BindingsSet contains no Bindings frames, and thus indicates\n    no match.\"\"\"\n    return hp.bindings_set_is_empty(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_single","title":"is_single","text":"<pre><code>is_single() -&gt; bool\n</code></pre> <p>Checks if a Bindings set contains a frame with no associations, and thus allows variables to take any value.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_single(self) -&gt; bool:\n    \"\"\"Checks if a Bindings set contains a frame with no associations, and\n    thus allows variables to take any value.\n    \"\"\"\n    return hp.bindings_set_is_single(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over all Bindings frames</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n    \"\"\"Returns an iterator over all Bindings frames\"\"\"\n    res = hp.bindings_set_list(self.c_set)\n    result = []\n    for r in res:\n        result.append(Bindings(r))\n    return iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.merge_into","title":"merge_into","text":"<pre><code>merge_into(input: Union[BindingsSet, Bindings])\n</code></pre> <p>Merges the contents of another BindingsSet or Bindings frame.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge_into(self, input: Union['BindingsSet', Bindings]):\n    \"\"\"Merges the contents of another BindingsSet or Bindings frame.\"\"\"\n    self.shadow_list = None\n    if isinstance(input, BindingsSet):\n        hp.bindings_set_merge_into(self.c_set, input.c_set);\n    else:\n        new_set = BindingsSet(input);\n        hp.bindings_set_merge_into(self.c_set, new_set.c_set);\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push","title":"push","text":"<pre><code>push(bindings: Bindings)\n</code></pre> <p>Adds a Bindings frame to an existing BindingsSet</p>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push--parameters","title":"Parameters","text":"<p>bindings:     The Bindings set to incorporate into set. Ownership of this argument is     taken by this function.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def push(self, bindings: Bindings):\n    \"\"\"Adds a Bindings frame to an existing BindingsSet\n\n    Parameters\n    ----------\n    bindings:\n        The Bindings set to incorporate into set. Ownership of this argument is\n        taken by this function.\n    \"\"\"\n    self.shadow_list = None\n    hp.bindings_set_push(self.c_set, bindings.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom","title":"ExpressionAtom","text":"<pre><code>ExpressionAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>An ExpressionAtom combines different kinds of Atoms, including expressions.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize an expression atom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_children","title":"get_children","text":"<pre><code>get_children()\n</code></pre> <p>Returns all children Atoms of an expression</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_children(self):\n    \"\"\"Returns all children Atoms of an expression\"\"\"\n    return [Atom._from_catom(catom) for catom in hp.atom_get_children(self.catom)]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n    \"\"\"Gets the type of the current Atom instance\"\"\"\n    return hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom","title":"GroundedAtom","text":"<pre><code>GroundedAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A GroundedAtom represents sub-symbolic knowledge. At the API level, it allows keeping data and behaviour inside an Atom. There are three aspects of a GroundedAtom which can be customized:</p> <pre><code>- the type of GroundedAtom is provided by the Atom itself;\n- the matching algorithm used by the Atom;\n- an Atom can be made executable, and used to apply sub-symbolic\n  operations to other Atoms as arguments.\n</code></pre> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a GroundedAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_grounded_type","title":"get_grounded_type","text":"<pre><code>get_grounded_type()\n</code></pre> <p>Retrieve the grounded type of the GroundedAtom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_grounded_type(self):\n    \"\"\"Retrieve the grounded type of the GroundedAtom.\"\"\"\n    return Atom._from_catom(hp.atom_get_grounded_type(self.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_object","title":"get_object","text":"<pre><code>get_object()\n</code></pre> <p>Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom, or convert supported Rust grounded objects into corresponding ValueObjects</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_object(self):\n    \"\"\"Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom,\n       or convert supported Rust grounded objects into corresponding ValueObjects\n    \"\"\"\n    if hp.atom_is_cgrounded(self.catom):\n        return hp.atom_get_object(self.catom)\n    typ = self.get_grounded_type()\n    if typ == AtomType.GROUNDED_SPACE:\n        from .base import SpaceRef\n        return SpaceRef._from_cspace(hp.atom_get_space(self.catom))\n    # NOTE: Rust and Python may have the same grounded type names, but we already\n    # distiguished them above\n    elif typ == S('Bool'):\n        return ValueObject(hp.gnd_get_bool(self.catom))\n    raise TypeError(\"Cannot get_object of unsupported non-C {self.catom}\")\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n    \"\"\"Gets the type of the current Atom instance\"\"\"\n    return hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject","title":"GroundedObject","text":"<pre><code>GroundedObject(content, id=None)\n</code></pre> <p>A GroundedObject holds some content and, optionally, an identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        return f'\"{self.content}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject","title":"MatchableObject","text":"<pre><code>MatchableObject(content, id=None)\n</code></pre> <p>             Bases: <code>ValueObject</code></p> <p>Represents an object that can be involved in a matching operation with an Atom.</p> <p>This class is meant to be subclassed by objects that define specific matching behavior with an Atom. It provides a stub method for the matching operation that raises a RuntimeError when called, which must be overridden by subclasses.</p> Inherits <p>ValueObject: The parent class that provides basic value-based equality and representation.</p> <p>Methods:</p> <ul> <li> <code>match_</code>           \u2013            <p>A stub method for matching the object with an Atom.</p> </li> </ul> Example <p>class MyMatchableObject(MatchableObject):     def match_(self, atom):         # Implement the matching logic here         pass</p> <p>my_obj = MyMatchableObject(\"some_value\") my_obj.match_(some_atom)  # Should not raise RuntimeError</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>Raised when the match_ method is called without being overridden by a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        return f'\"{self.content}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.match_","title":"match_","text":"<pre><code>match_(atom)\n</code></pre> <p>A stub method for matching the object with an Atom.</p> <p>This method is intended to be overridden by subclasses to provide specific matching behavior with an Atom.</p> <p>Parameters:</p> <ul> <li> <code>atom</code>             (<code>Atom</code>)         \u2013          <p>An Atom object to match against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>Raised when this method is called without being overridden in a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_(self, atom):\n    \"\"\"\n    A stub method for matching the object with an Atom.\n\n    This method is intended to be overridden by subclasses to provide specific\n    matching behavior with an Atom.\n\n    Parameters:\n        atom (Atom): An Atom object to match against.\n\n    Raises:\n        RuntimeError: Raised when this method is called without being overridden in a subclass.\n    \"\"\"\n    raise RuntimeError(\"MatchableObject::match_() is not implemented\")\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.NoReduceError","title":"NoReduceError","text":"<p>             Bases: <code>Exception</code></p> <p>Custom exception; raised when a reduction operation cannot be performed.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject","title":"OperationObject","text":"<pre><code>OperationObject(name, op, unwrap=True)\n</code></pre> <p>             Bases: <code>GroundedObject</code></p> <p>An OperationObject represents an operation as a grounded object, allowing for more advanced logic like lazy evaluation, type-checking, and more.</p> Inherits <p>GroundedObject: The parent class that provides the basic wrapper around content.</p> <p>Attributes:</p> <ul> <li> <code>unwrap</code>             (<code>bool</code>)         \u2013          <p>Determines whether to unwrap the content of GroundedAtoms            when passed as arguments to the operation.</p> </li> </ul> Properties <p>op: Returns the operation function. name: Returns the identifier name for this operation object.</p> <p>Methods:</p> <ul> <li> <code>execute</code>           \u2013            <p>Executes the operation with the provided arguments.</p> </li> <li> <code>__eq__</code>           \u2013            <p>Compares the equality of this OperationObject instance with another.</p> </li> </ul> Example <p>def add(a, b):     return a + b</p> <p>op_obj = OperationObject(\"addition\", add) result = op_obj.execute(3, 4)</p> <p>Parameters:     name (str): The identifier for this operation.     op (function): The function representing the operation.     unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying                              the operation. Defaults to True.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, name, op, unwrap=True):\n    \"\"\"\n    Initializes a new OperationObject with a name identifier, operation function,\n    and an optional unwrap flag.\n    Parameters:\n        name (str): The identifier for this operation.\n        op (function): The function representing the operation.\n        unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying\n                                 the operation. Defaults to True.\n\n    \"\"\"\n    super().__init__(op, name)\n    self.unwrap = unwrap\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the identifier name for this operation object.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.op","title":"op  <code>property</code>","text":"<pre><code>op\n</code></pre> <p>Returns the operation function.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this OperationObject with another based on their names.</p> <p>Parameters:</p> <ul> <li> <code>other</code>             (<code>OperationObject</code>)         \u2013          <p>Another OperationObject instance to compare.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>True if both OperationObjects have the same name; False otherwise.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares the equality of this OperationObject with another based on their names.\n\n    Parameters:\n        other (OperationObject): Another OperationObject instance to compare.\n\n    Returns:\n        True if both OperationObjects have the same name; False otherwise.\n    \"\"\"\n    return isinstance(other, OperationObject) and self.name == other.name\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        return f'\"{self.content}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.execute","title":"execute","text":"<pre><code>execute(*args, res_typ=AtomType.UNDEFINED)\n</code></pre> <p>Executes the operation with the provided arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>         \u2013          <p>Arguments to pass to the operation function.</p> </li> <li> <code>res_typ</code>             (<code>AtomType</code>, default:                 <code>UNDEFINED</code> )         \u2013          <p>The expected result type. Defaults to AtomType.UNDEFINED.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>The result of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoReduceError</code>           \u2013          <p>Raised when <code>unwrap=True</code> and a non-GroundedAtom argument is provided.</p> </li> <li> <code>RuntimeError</code>           \u2013          <p>Raised when the result of the operation is not a list.</p> </li> </ul> Note <p>Depending on the <code>unwrap</code> attribute, this method will either unwrap GroundedAtoms before passing them to the operation or pass them as is.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def execute(self, *args, res_typ=AtomType.UNDEFINED):\n    \"\"\"\n    Executes the operation with the provided arguments.\n\n    Parameters:\n        *args: Arguments to pass to the operation function.\n        res_typ (AtomType, optional): The expected result type. Defaults to AtomType.UNDEFINED.\n\n    Returns:\n        The result of the operation.\n\n    Raises:\n        NoReduceError: Raised when `unwrap=True` and a non-GroundedAtom argument is provided.\n        RuntimeError: Raised when the result of the operation is not a list.\n\n    Note:\n        Depending on the `unwrap` attribute, this method will either unwrap GroundedAtoms\n        before passing them to the operation or pass them as is.\n    \"\"\"\n    # type-check?\n    if self.unwrap:\n        for arg in args:\n            if not isinstance(arg, GroundedAtom):\n                # REM:\n                # Currently, applying grounded operations to pure atoms is not reduced.\n                # If we want, we can raise an exception, or form an error expression instead,\n                # so a MeTTa program can catch and analyze it.\n                # raise RuntimeError(\"Grounded operation \" + self.name + \" with unwrap=True expects only grounded arguments\")\n                raise NoReduceError()\n        args = [arg.get_object().content for arg in args]\n        return [G(ValueObject(self.op(*args)), res_typ)]\n    else:\n        result = self.op(*args)\n        if not isinstance(result, list):\n            raise RuntimeError(\"Grounded operation `\" + self.name + \"` should return list\")\n        return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom","title":"SymbolAtom","text":"<pre><code>SymbolAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A SymbolAtom represents a single concept, identified by name. If two symbols have the same name, they reference the same concept.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a SymbolAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n    \"\"\"Gets the type of the current Atom instance\"\"\"\n    return hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject","title":"ValueObject","text":"<pre><code>ValueObject(content, id=None)\n</code></pre> <p>             Bases: <code>GroundedObject</code></p> <p>A ValueObject is a specialized form of GroundedObject, which treats its content as a value. It allows for equality comparison between the content of two ValueObjects.</p> Example <p>obj1 = ValueObject(5) obj2 = ValueObject(5) obj3 = ValueObject(6)</p> <p>print(obj1 == obj2)  # True print(obj1 == obj3)  # False</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n    \"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\n    self.content = content\n    self.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        return f'\"{self.content}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom","title":"VariableAtom","text":"<pre><code>VariableAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A VariableAtom represents a variable in an expression. It serves as a placeholder that can be matched with, or bound to other Atoms.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n    \"\"\"Initialize a VariableAtom\"\"\"\n    super().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees an Atom and all associated resources.\"\"\"\n    hp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\n    return (isinstance(other, Atom) and\n            hp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Renders a human-readable text description of the Atom.\"\"\"\n    return hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n    \"\"\"Returns the name of the Atom.\"\"\"\n    return hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n    \"\"\"Gets the type of the current Atom instance\"\"\"\n    return hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n    \"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\n    res = hp.atom_iterate(self.catom)\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n    \"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\n    return BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.E","title":"E","text":"<pre><code>E(*args)\n</code></pre> <p>A convenient method to construct an ExpressionAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def E(*args):\n    \"\"\"A convenient method to construct an ExpressionAtom\"\"\"\n    return ExpressionAtom(hp.atom_expr([atom.catom for atom in args]))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.G","title":"G","text":"<pre><code>G(object, type=AtomType.UNDEFINED)\n</code></pre> <p>A convenient method to construct a GroundedAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def G(object, type=AtomType.UNDEFINED):\n    \"\"\"A convenient method to construct a GroundedAtom\"\"\"\n    assert hasattr(object, \"copy\"), \"Method copy should be implemented by grounded object\"\n    return GroundedAtom(hp.atom_gnd(object, type.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableAtom","title":"MatchableAtom","text":"<pre><code>MatchableAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def MatchableAtom(value, type_name=None, atom_id=None):\n    \"\"\"\n    Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.\n    \"\"\"\n    return G(MatchableObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationAtom","title":"OperationAtom","text":"<pre><code>OperationAtom(name, op, type_names=None, unwrap=True)\n</code></pre> <p>An OperationAtom wraps an operation with optional type information into a GroundedAtom and associates a name with it. Useful for registering custom operations that can be executed in an Atom-based computational environment.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def OperationAtom(name, op, type_names=None, unwrap=True):\n    \"\"\"\n    An OperationAtom wraps an operation with optional type information into a GroundedAtom\n    and associates a name with it. Useful for registering custom operations\n    that can be executed in an Atom-based computational environment.\n    \"\"\"\n    return G(OperationObject(name, op, unwrap), _type_sugar(type_names))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.S","title":"S","text":"<pre><code>S(name)\n</code></pre> <p>A convenient method to construct a SymbolAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def S(name):\n    \"\"\"A convenient method to construct a SymbolAtom\"\"\"\n    return SymbolAtom(hp.atom_sym(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.V","title":"V","text":"<pre><code>V(name)\n</code></pre> <p>A convenient method to construct a VariableAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def V(name):\n    \"\"\"A convenient method to construct a VariableAtom\"\"\"\n    return VariableAtom(hp.atom_var(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueAtom","title":"ValueAtom","text":"<pre><code>ValueAtom(value, type_name=None, atom_id=None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def ValueAtom(value, type_name=None, atom_id=None):\n    \"\"\"Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier.\"\"\"\n    return G(ValueObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.atoms_are_equivalent","title":"atoms_are_equivalent","text":"<pre><code>atoms_are_equivalent(first, second)\n</code></pre> <p>Check if two atoms are equivalent</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def atoms_are_equivalent(first, second):\n    \"\"\"Check if two atoms are equivalent\"\"\"\n    return hp.atoms_are_equivalent(first.catom, second.catom)\n</code></pre>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#hyperon.base","title":"base","text":""},{"location":"reference/base/#hyperon.base.AbstractSpace","title":"AbstractSpace","text":"<pre><code>AbstractSpace()\n</code></pre> <p>A virtual base class upon which Spaces can be implemented in Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialiize the AbstractSpace. Does nothing in the base class\"\"\"\n    return\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::add() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of atoms in the atom space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of atoms in the atom space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the Space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the Space. Optional for derived classes.\n    \"\"\"\n    None\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Performs the specified query on the Space. Should be overridden to return a BindingsSet as the result of the query.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Performs the specified query on the Space.\n    Should be overridden to return a BindingsSet as the result of the query.\n    \"\"\"\n    raise RuntimeError(\"Space::query() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::remove() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.replace","title":"replace","text":"<pre><code>replace(atom, replacement)\n</code></pre> <p>Replaces an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, atom, replacement):\n    \"\"\"\n    Replaces an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\n    raise RuntimeError(\"Space::replace() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace","title":"GroundingSpace","text":"<pre><code>GroundingSpace()\n</code></pre> <p>             Bases: <code>AbstractSpace</code></p> <p>A wrapper over the native GroundingSpace implementation, which can be subclassed and extended within Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize GroundingSpace and its underlying native implementation.\"\"\"\n    super().__init__()\n    # self.cspace = hp.space_new_grounding()\n    self.gspace = GroundingSpaceRef()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n    \"\"\"\n    Adds an Atom to the atom space.\n    \"\"\"\n    self.gspace.add_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of Atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Counts the number of Atoms in the atom space.\n    \"\"\"\n    return self.gspace.atom_count()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n    \"\"\"\n    Returns an iterator over atoms in the atom space.\n    \"\"\"\n    return iter(self.gspace.get_atoms())\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Delegates the query to the underlying native GroundingSpace and returns the result BindingsSet</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n    \"\"\"\n    Delegates the query to the underlying native GroundingSpace\n    and returns the result BindingsSet\n    \"\"\"\n    return self.gspace.query(query_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n    \"\"\"\n    Removes an Atom from the atom space.\n    \"\"\"\n    return self.gspace.remove_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.replace","title":"replace","text":"<pre><code>replace(from_atom, to_atom)\n</code></pre> <p>Replaces an Atom in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, from_atom, to_atom):\n    \"\"\"\n    Replaces an Atom in the atom space.\n    \"\"\"\n    return self.gspace.replace_atom(from_atom, to_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef","title":"GroundingSpaceRef","text":"<pre><code>GroundingSpaceRef(cspace=None)\n</code></pre> <p>             Bases: <code>SpaceRef</code></p> <p>A reference to a native GroundingSpace, implemented by the MeTTa core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cspace = None):\n    \"\"\"\n    Initialize a new GroundingSpaceRef.\n    If a CSpace object is provided, use it; otherwise create a new GroundingSpace.\n    \"\"\"\n    if cspace is None:\n        self.cspace = hp.space_new_grounding()\n    else:\n        self.cspace = cspace\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(gnd_space, expr)\n</code></pre> <p>A wrapper class for the MeTTa interpreter that handles the interpretation of expressions in a given grounding space.</p> <p>NOTE: This is a low-level API, and most applications would be better served by a <code>MeTTa</code> runner object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, gnd_space, expr):\n    \"\"\"\n    Initializes the interpreter with the given grounding space and expression.\n    \"\"\"\n    self.step_result = hp.interpret_init(gnd_space.cspace, expr.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_result","title":"get_result","text":"<pre><code>get_result()\n</code></pre> <p>Retrieves the final outcome of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_result(self):\n    \"\"\"\n    Retrieves the final outcome of the interpretation plan.\n    \"\"\"\n    if self.has_next():\n        raise RuntimeError(\"Plan execution is not finished\")\n    return hp.step_get_result(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_step_result","title":"get_step_result","text":"<pre><code>get_step_result()\n</code></pre> <p>Gets the current result of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_step_result(self):\n    \"\"\"\n    Gets the current result of the interpretation plan.\n    \"\"\"\n    return self.step_result\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.has_next","title":"has_next","text":"<pre><code>has_next()\n</code></pre> <p>Checks if there are more steps to execute in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def has_next(self):\n    \"\"\"\n    Checks if there are more steps to execute in the interpretation plan.\n    \"\"\"\n    return hp.step_has_next(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.next","title":"next","text":"<pre><code>next()\n</code></pre> <p>Executes the next step in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def next(self):\n    \"\"\"\n    Executes the next step in the interpretation plan.\n    \"\"\"\n    if not self.has_next():\n        raise StopIteration()\n    self.step_result = hp.interpret_step(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser","title":"SExprParser","text":"<pre><code>SExprParser(text)\n</code></pre> <p>A class responsible for parsing S-expressions (Symbolic Expressions). This class wraps around a SExprParser object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, text):\n    \"\"\"Initialize a new SExprParser object.\"\"\"\n    self.cparser = hp.CSExprParser(text)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse","title":"parse","text":"<pre><code>parse(tokenizer)\n</code></pre> <p>Parses the S-expression using the provided Tokenizer.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse(self, tokenizer):\n    \"\"\"\n    Parses the S-expression using the provided Tokenizer.\n    \"\"\"\n    catom = self.cparser.parse(tokenizer.ctokenizer)\n    if (catom is None):\n        err_str = self.cparser.sexpr_parser_err_str()\n        if (err_str is None):\n            return None\n        else:\n            raise SyntaxError(err_str)\n    else:\n        return Atom._from_catom(catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse_to_syntax_tree","title":"parse_to_syntax_tree","text":"<pre><code>parse_to_syntax_tree()\n</code></pre> <p>Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse_to_syntax_tree(self):\n    \"\"\"\n    Parses the S-expression into a SyntaxNode representing the top-level of a syntax tree.\n    \"\"\"\n    cnode = self.cparser.parse_to_syntax_tree()\n    return SyntaxNode(cnode) if cnode is not None else None\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef","title":"SpaceRef","text":"<pre><code>SpaceRef(space_obj)\n</code></pre> <p>A reference to a Space, which may be accessed directly, wrapped in a grounded atom, or passed to a MeTTa interpreter.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, space_obj):\n    \"\"\"\n    Initialize a new SpaceRef based on the given space object, either a CSpace \n    or a custom Python object.\n    \"\"\"\n    if type(space_obj) is hp.CSpace:\n        self.cspace = space_obj\n    else:\n        self.cspace = hp.space_new_custom(space_obj)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"Free the underlying CSpace object \"\"\"\n    hp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\n    return hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n    \"\"\"\n    Add an Atom to the Space.\n    \"\"\"\n    hp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n    \"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\n    return hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n    \"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\n    res = hp.space_list(self.cspace)\n    if res == None:\n        return None\n    result = []\n    for r in res:\n        result.append(Atom._from_catom(r))\n    return result\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n    \"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\n    return hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n    \"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\n    result = hp.space_query(self.cspace, pattern.catom)\n    return BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n    \"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\n    return hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n    \"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\n    return hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n    \"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\n    return [Atom._from_catom(catom) for catom in\n            hp.space_subst(self.cspace, pattern.catom,\n                                     templ.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode","title":"SyntaxNode","text":"<pre><code>SyntaxNode(cnode)\n</code></pre> <p>A class representing a node in a parsed syntax tree</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cnode):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    self.cnode = cnode\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor for the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor for the SyntaxNode\n    \"\"\"\n    hp.syntax_node_free(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Returns the type of a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_type(self):\n    \"\"\"\n    Returns the type of a SyntaxNode\n    \"\"\"\n    return hp.syntax_node_type(self.cnode)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.src_range","title":"src_range","text":"<pre><code>src_range()\n</code></pre> <p>Returns the range of offsets into the source code of the text represented by the SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def src_range(self):\n    \"\"\"\n    Returns the range of offsets into the source code of the text represented by the SyntaxNode\n    \"\"\"\n    range_tuple = hp.syntax_node_src_range(self.cnode)\n    return range(range_tuple[0], range_tuple[1])\n</code></pre>"},{"location":"reference/base/#hyperon.base.SyntaxNode.unroll","title":"unroll","text":"<pre><code>unroll()\n</code></pre> <p>Returns a list of all leaf nodes recursively contained within a SyntaxNode</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def unroll(self):\n    \"\"\"\n    Returns a list of all leaf nodes recursively contained within a SyntaxNode\n    \"\"\"\n    syntax_nodes = []\n    for cnode in hp.syntax_node_unroll(self.cnode):\n        syntax_nodes.append(SyntaxNode(cnode))\n    return syntax_nodes\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer","title":"Tokenizer","text":"<pre><code>Tokenizer(ctokenizer=None)\n</code></pre> <p>A class responsible for text tokenization in the context of Hyperon. This class wraps around a Tokenizer object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, ctokenizer = None):\n    \"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\n    if ctokenizer is None:\n        self.ctokenizer = hp.tokenizer_new()\n    else:\n        self.ctokenizer = ctokenizer\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor that frees the underlying resources when the Tokenizer instance is destroyed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n    \"\"\"\n    Destructor that frees the underlying resources when the Tokenizer instance is destroyed.\n    \"\"\"\n    hp.tokenizer_free(self.ctokenizer)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.register_token","title":"register_token","text":"<pre><code>register_token(regex, constr)\n</code></pre> <p>Registers a new custom Token in the Tokenizer based on a regular expression.</p> <p>Parameters:</p> <p>regex:     A string representing the regular expression to match incoming text.     Hyperon uses the Rust RegEx engine and syntax. constr:     A constructor function for generating a new atom when the regex is triggered.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def register_token(self, regex, constr):\n    \"\"\"\n    Registers a new custom Token in the Tokenizer based on a regular expression.\n\n    Parameters:\n    ----------\n    regex:\n       A string representing the regular expression to match incoming text.\n       Hyperon uses the Rust RegEx engine and syntax.\n   constr:\n       A constructor function for generating a new atom when the regex is triggered.\n   \"\"\"\n    hp.tokenizer_register_token(self.ctokenizer, regex, constr)\n</code></pre>"},{"location":"reference/base/#hyperon.base.atom_is_error","title":"atom_is_error","text":"<pre><code>atom_is_error(atom)\n</code></pre> <p>Checks whether an Atom is an error expression</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_is_error(atom):\n    \"\"\"Checks whether an Atom is an error expression\"\"\"\n    return hp.atom_is_error(atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.check_type","title":"check_type","text":"<pre><code>check_type(gnd_space, atom, type)\n</code></pre> <p>Checks whether the given Atom has the specified type in the given space context.</p>"},{"location":"reference/base/#hyperon.base.check_type--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check type:     A pointer to the atom_t or atom_ref_t representing the type to check against</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def check_type(gnd_space, atom, type):\n    \"\"\"\n    Checks whether the given Atom has the specified type in the given space context.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n    type:\n        A pointer to the atom_t or atom_ref_t representing the type to check against\n    \"\"\"\n\n    return hp.check_type(gnd_space.cspace, atom.catom, type.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.get_atom_types","title":"get_atom_types","text":"<pre><code>get_atom_types(gnd_space, atom)\n</code></pre> <p>Provides all types for the given Atom in the context of the given Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atom_types(gnd_space, atom):\n    \"\"\"Provides all types for the given Atom in the context of the given Space.\"\"\"\n    result = hp.get_atom_types(gnd_space.cspace, atom.catom)\n    return [Atom._from_catom(catom) for catom in result]\n</code></pre>"},{"location":"reference/base/#hyperon.base.interpret","title":"interpret","text":"<pre><code>interpret(gnd_space, expr)\n</code></pre> <p>Parses the given expression in the specified grounding space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def interpret(gnd_space, expr):\n    \"\"\"\n    Parses the given expression in the specified grounding space.\n    \"\"\"\n    interpreter = Interpreter(gnd_space, expr)\n    while interpreter.has_next():\n        interpreter.next()\n    return [Atom._from_catom(catom) for catom in interpreter.get_result()]\n</code></pre>"},{"location":"reference/base/#hyperon.base.validate_atom","title":"validate_atom","text":"<pre><code>validate_atom(gnd_space, atom)\n</code></pre> <p>Checks whether the given Atom is correctly typed.</p>"},{"location":"reference/base/#hyperon.base.validate_atom--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check</p>"},{"location":"reference/base/#hyperon.base.validate_atom--returns","title":"Returns","text":"<p>True if the Atom is correctly typed, otherwise false</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def validate_atom(gnd_space, atom):\n    \"\"\"\n    Checks whether the given Atom is correctly typed.\n\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n\n    Returns\n    -------\n    True if the Atom is correctly typed, otherwise false\n    \"\"\"\n    return hp.validate_atom(gnd_space.cspace, atom.catom)\n</code></pre>"},{"location":"reference/ext/","title":"Ext","text":""},{"location":"reference/ext/#hyperon.ext","title":"ext","text":""},{"location":"reference/ext/#hyperon.ext.register_atoms","title":"register_atoms","text":"<pre><code>register_atoms(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and atoms in MeTTa tokenizer using MeTTa.register_atom() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_atoms--parameters","title":"Parameters","text":"<p>pass_metta:     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_atoms(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and atoms in MeTTa tokenizer using MeTTa.register_atom() method.\n\n    Parameters\n    ----------\n    pass_metta:\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    def register_atoms_internal(metta, regs):\n        for rex, atom in regs.items():\n            metta.register_atom(rex, atom)\n    return register_results(register_atoms_internal, args, kwargs)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_results","title":"register_results","text":"<pre><code>register_results(method, args, kwargs)\n</code></pre> <p>Returns a decorator for registering the results of a method. The behavior of the decorator depends on whether it is used with or without arguments.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_results(method, args, kwargs):\n    \"\"\"Returns a decorator for registering the results of a method.\n    The behavior of the decorator depends on whether it is used with or without arguments.\"\"\"\n\n    # Case 1: Decorator used without arguments (i.e., @decorator instead of @decorator(args))\n    if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n        func = args[0]  # func is the decorated function\n\n        # Define the decorator\n        def metta_register(metta):\n            # Register the results of calling the decorated function using the provided method\n            method(metta, func())\n        return metta_register\n\n    # Case 2: Decorator used with arguments (i.e., @decorator(args))\n    else:\n        # Check if the decorator is used with arguments\n        pass_metta = kwargs.get('pass_metta', False)\n\n        # Define the decorator\n        def inner(func):\n            def metta_register(metta):\n                # Get the results of calling the decorated function\n                regs = func(metta) if pass_metta else func()\n                # Register the results using the provided method\n                method(metta, regs)\n            return metta_register\n        return inner\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_tokens","title":"register_tokens","text":"<pre><code>register_tokens(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and lambdas in MeTTa tokenizer using MeTTa.register_token() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_tokens--parameters","title":"Parameters","text":"<p>pass_metta : bool, optional     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_tokens(*args, **kwargs):\n    \"\"\"Function decorator which registers returned pairs of regular expressions\n    and lambdas in MeTTa tokenizer using MeTTa.register_token() method.\n\n    Parameters\n    ----------\n    pass_metta : bool, optional\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\n    def register_tokens_internal(metta, regs):\n        for rex, lam in regs.items():\n            metta.register_token(rex, lam)\n    return register_results(register_tokens_internal, args, kwargs)\n</code></pre>"},{"location":"reference/runner/","title":"Runner","text":""},{"location":"reference/runner/#hyperon.runner","title":"runner","text":""},{"location":"reference/runner/#hyperon.runner.Environment","title":"Environment","text":"<p>This class contains the API for configuring the host platform interface used by MeTTa</p>"},{"location":"reference/runner/#hyperon.runner.Environment.config_dir","title":"config_dir","text":"<pre><code>config_dir()\n</code></pre> <p>Returns the config dir in the common environment</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def config_dir():\n    \"\"\"Returns the config dir in the common environment\"\"\"\n    path = hp.environment_config_dir()\n    if (len(path) &gt; 0):\n        return path\n    else:\n        return None\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.custom_env","title":"custom_env","text":"<pre><code>custom_env(working_dir=None, config_dir=None, create_config=False, disable_config=False, is_test=False, include_paths=[])\n</code></pre> <p>Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def custom_env(working_dir = None, config_dir = None, create_config = False, disable_config = False, is_test = False, include_paths = []):\n    \"\"\"Returns an EnvBuilder object that can be used to init a MeTTa runner, if you need multiple environments to coexist in the same process\"\"\"\n    builder = hp.env_builder_start()\n    if (working_dir is not None):\n        hp.env_builder_set_working_dir(builder, working_dir)\n    if (config_dir is not None):\n        hp.env_builder_set_config_dir(builder, config_dir)\n    if (create_config):\n        hp.env_builder_create_config_dir(builder)\n    if (disable_config):\n        hp.env_builder_disable_config_dir(builder)\n    if (is_test):\n        hp.env_builder_set_is_test(True)\n    for path in reversed(include_paths):\n        hp.env_builder_add_include_path(builder, path)\n    return builder\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.init_common_env","title":"init_common_env","text":"<pre><code>init_common_env(working_dir=None, config_dir=None, create_config=False, disable_config=False, is_test=False, include_paths=[])\n</code></pre> <p>Initialize the common environment with the supplied args</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def init_common_env(working_dir = None, config_dir = None, create_config = False, disable_config = False, is_test = False, include_paths = []):\n    \"\"\"Initialize the common environment with the supplied args\"\"\"\n    builder = Environment.custom_env(working_dir, config_dir, create_config, disable_config, is_test, include_paths)\n    return hp.env_builder_init_common_env(builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.Environment.test_env","title":"test_env","text":"<pre><code>test_env()\n</code></pre> <p>Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def test_env():\n    \"\"\"Returns an EnvBuilder object specifying a unit-test environment, that can be used to init a MeTTa runner\"\"\"\n    return hp.env_builder_use_test_env()\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa","title":"MeTTa","text":"<pre><code>MeTTa(cmetta=None, space=None, env_builder=None)\n</code></pre> <p>This class contains the MeTTa program execution utilities</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, cmetta = None, space = None, env_builder = None):\n    self.pymods = {}\n\n    if cmetta is not None:\n        self.cmetta = cmetta\n    else:\n        if space is None:\n            space = GroundingSpaceRef()\n        if env_builder is None:\n            env_builder = hp.env_builder_use_default()\n        self.cmetta = hp.metta_new(space.cspace, env_builder)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two MeTTa runner handles point to the same runner.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Checks if two MeTTa runner handles point to the same runner.\"\"\"\n    return (hp.metta_eq(self.cmetta, other.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.import_file","title":"import_file","text":"<pre><code>import_file(fname)\n</code></pre> <p>Loads the program file and runs it</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def import_file(self, fname):\n    \"\"\"Loads the program file and runs it\"\"\"\n    path = fname.split(os.sep)\n    if len(path) == 1:\n        path = ['.'] + path\n    f = open(os.sep.join(path), \"r\")\n    program = f.read()\n    f.close()\n    # changing cwd\n    # TODO: Changing the working dir will not be necessary when the stdlib ops can access the correct runner context.  See https://github.com/trueagi-io/hyperon-experimental/issues/410\n    prev_cwd = os.getcwd()\n    os.chdir(os.sep.join(path[:-1]))\n    result = self.run(program)\n    # restoring cwd\n    os.chdir(prev_cwd)\n    return result\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_py_module","title":"load_py_module","text":"<pre><code>load_py_module(name)\n</code></pre> <p>Loads the given python module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_py_module(self, name):\n    \"\"\"Loads the given python module\"\"\"\n    if not isinstance(name, str):\n        name = repr(name)\n    try:\n        mod = import_module(name)\n        self.pymods[name] = mod\n        for n in dir(mod):\n            obj = getattr(mod, n)\n            if '__name__' in dir(obj) and obj.__name__ == 'metta_register':\n                obj(self)\n        return mod\n    except:\n        return None\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_py_module_from_mod_or_file","title":"load_py_module_from_mod_or_file","text":"<pre><code>load_py_module_from_mod_or_file(mod_name)\n</code></pre> <p>Loads the given python-implemented MeTTa module, first using python's module-namespace logic, then by searching for files in the MeTTa environment's search path</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_py_module_from_mod_or_file(self, mod_name):\n    \"\"\"Loads the given python-implemented MeTTa module, first using python's module-namespace logic,\n    then by searching for files in the MeTTa environment's search path\"\"\"\n\n    # First, see if the module is already available to Python\n    if not isinstance(mod_name, str):\n        mod_name = repr(mod_name)\n    mod = MeTTa.load_py_module(self, mod_name)\n    if mod is None:\n        # If that failed, try and load the module from a file\n        file_name = mod_name if \".py\" in mod_name else \\\n                    mod_name.replace('.', os.sep) + \".py\"\n\n        # Check each search path directory in order, until we find the module we're looking for\n        num_search_paths = hp.metta_search_path_cnt(self.cmetta)\n        search_path_idx = 0\n        found_path = None\n        while search_path_idx &lt; num_search_paths:\n            search_path = hp.metta_nth_search_path(self.cmetta, search_path_idx)\n            test_path = os.path.join(search_path, file_name)\n            if os.path.exists(test_path):\n                found_path = test_path\n                break\n            search_path_idx += 1\n\n        if found_path is not None:\n            module = MeTTa.load_py_module_from_path(self, mod_name, found_path)\n            if module is None:\n                raise RuntimeError(\"Failed to load module \" + mod_name + \"; error while loading file: \" + file_name)\n        else:\n            raise RuntimeError(\"Failed to load module \" + mod_name + \"; could not locate file: \" + file_name)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_py_module_from_path","title":"load_py_module_from_path","text":"<pre><code>load_py_module_from_path(mod_name, path)\n</code></pre> <p>Loads the given python-implemented MeTTa module from a file at the specified path</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_py_module_from_path(self, mod_name, path):\n    \"\"\"Loads the given python-implemented MeTTa module from a file at the specified path\"\"\"\n\n    spec = importlib.util.spec_from_file_location(mod_name, path)\n    module = importlib.util.module_from_spec(spec)\n    mod_name = mod_name.split(os.sep)[-1]\n    sys.modules[mod_name] = module\n    spec.loader.exec_module(module)\n    return MeTTa.load_py_module(self, mod_name)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_all","title":"parse_all","text":"<pre><code>parse_all(program)\n</code></pre> <p>Parse the entire program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_all(self, program):\n    \"\"\"Parse the entire program\"\"\"\n    return list(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_single","title":"parse_single","text":"<pre><code>parse_single(program)\n</code></pre> <p>Parse the next single line in the program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_single(self, program):\n    \"\"\"Parse the next single line in the program\"\"\"\n    return next(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n    \"\"\"Registers an Atom\"\"\"\n    self.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n    \"\"\"Registers a token\"\"\"\n    self.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.run","title":"run","text":"<pre><code>run(program, flat=False)\n</code></pre> <p>Runs the program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run(self, program, flat=False):\n    \"\"\"Runs the program\"\"\"\n    parser = SExprParser(program)\n    results = hp.metta_run(self.cmetta, parser.cparser)\n    err_str = hp.metta_err_str(self.cmetta)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Gets the metta space</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n    \"\"\"Gets the metta space\"\"\"\n    return GroundingSpaceRef._from_cspace(hp.metta_space(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Gets the tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n    \"\"\"Gets the tokenizer\"\"\"\n    return Tokenizer._from_ctokenizer(hp.metta_tokenizer(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState","title":"RunnerState","text":"<pre><code>RunnerState(metta, program)\n</code></pre> <p>The state for an in-flight MeTTa interpreter handling the interpretation and evaluation of atoms in a given grounding space.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, metta, program):\n    \"\"\"Initialize a RunnerState with a MeTTa object and a program to run\"\"\"\n    parser = SExprParser(program)\n    #WARNING the C parser object has a reference to the text buffer, and hyperonpy's CSExprParser\n    #  copies the buffer into an owned string.  So we need to make sure this parser isn't freed\n    #  until the RunnerState is done with it.\n    self.parser = parser\n    self.cstate = hp.runner_state_new_with_parser(metta.cmetta, parser.cparser)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees a RunnerState and all associated resources.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __del__(self):\n    \"\"\"Frees a RunnerState and all associated resources.\"\"\"\n    hp.runner_state_free(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.current_results","title":"current_results","text":"<pre><code>current_results(flat=False)\n</code></pre> <p>Returns the current in-progress results from an in-flight program evaluation</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def current_results(self, flat=False):\n    \"\"\"\n    Returns the current in-progress results from an in-flight program evaluation\n    \"\"\"\n    results = hp.runner_state_current_results(self.cstate)\n    if flat:\n        return [Atom._from_catom(catom) for result in results for catom in result]\n    else:\n        return [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.is_complete","title":"is_complete","text":"<pre><code>is_complete()\n</code></pre> <p>Returns True if the runner has concluded, or False if there are more steps remaining to execute</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def is_complete(self):\n    \"\"\"\n    Returns True if the runner has concluded, or False if there are more steps remaining to execute\n    \"\"\"\n    return hp.runner_state_is_complete(self.cstate)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.RunnerState.run_step","title":"run_step","text":"<pre><code>run_step()\n</code></pre> <p>Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run_step(self):\n    \"\"\"\n    Executes the next step in the interpretation plan, or begins interpretation of the next atom in the stream of MeTTa code.\n    \"\"\"\n    hp.runner_state_step(self.cstate)\n    err_str = hp.runner_state_err_str(self.cstate)\n    if (err_str is not None):\n        raise RuntimeError(err_str)\n</code></pre>"},{"location":"reference/stdlib/","title":"Stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib","title":"stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib.Char","title":"Char","text":"<pre><code>Char(char)\n</code></pre> <p>Emulate Char type as in a traditional FPL</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, char):\n    if len(char) != 1:\n        raise ValueError(\"A Char object must be initialized with a single character.\")\n    self.char = char\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject","title":"RegexMatchableObject","text":"<pre><code>RegexMatchableObject(content, id=None)\n</code></pre> <p>             Bases: <code>MatchableObject</code></p> <p>To match atoms with regular expressions</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, content, id=None):\n    super().__init__(content, id)\n\n    self.content = self.content.replace(\"[[\", \"(\").replace(\"]]\", \")\").replace(\"~\", \" \")\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n    # TODO: ?typecheck for the contents\n    return isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns the object's ID if present, or a string representation of\n    its content if not.\"\"\"\n    # Overwrite Python default representation of a string to use\n    # double quotes instead of single quotes.\n    if isinstance(self.content, str):\n        return f'\"{self.content}\"'\n\n    # Use default representation for everything else\n    return repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.RegexMatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Returns a copy of this GroundedObject instance.\n\n    Note: Currently, this method returns the original instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.text_ops","title":"text_ops","text":"<pre><code>text_ops()\n</code></pre> <p>Add text operators</p> <p>repr: convert Atom to string. parse: convert String to Atom. stringToChars: convert String to tuple of Char. charsToString: convert tuple of Char to String.</p> <p>see test_stdlib.py for examples.</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>@register_atoms\ndef text_ops():\n    \"\"\"Add text operators\n\n    repr: convert Atom to string.\n    parse: convert String to Atom.\n    stringToChars: convert String to tuple of Char.\n    charsToString: convert tuple of Char to String.\n\n    see test_stdlib.py for examples.\n\n    \"\"\"\n\n    reprAtom = OperationAtom('repr', lambda a: [ValueAtom(repr(a))],\n                             ['Atom', 'String'], unwrap=False)\n    parseAtom = OperationAtom('parse', lambda s: [ValueAtom(SExprParser(str(s)[1:-1]).parse(Tokenizer()))],\n                              ['String', 'Atom'], unwrap=False)\n    stringToCharsAtom = OperationAtom('stringToChars', lambda s: [ValueAtom(E(*[ValueAtom(Char(c)) for c in str(s)[1:-1]]))],\n                                      ['String', 'Atom'], unwrap=False)\n    charsToStringAtom = OperationAtom('charsToString', lambda a: [ValueAtom(\"\".join([str(c)[1:-1] for c in a.get_children()]))],\n                                      ['Atom', 'String'], unwrap=False)\n    return {\n        r\"repr\": reprAtom,\n        r\"parse\": parseAtom,\n        r\"stringToChars\": stringToCharsAtom,\n        r\"charsToString\": charsToStringAtom\n    }\n</code></pre>"}]}